using System.Security.Cryptography;

namespace Kevahu.Microservices.Core.SecureSocket.Cryptography
{
    /// <summary>
    /// Facilitates secure key exchange using RSA encryption and signing. This class generates a
    /// symmetric token key and securely transmits it by encrypting it with the recipient's public
    /// key and signing it with the sender's private key. The sender's public key is included for verification.
    /// </summary>
    public class RsaTokenGenerator
    {
        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaTokenGenerator"/> class with the
        /// necessary RSA keys. Generates an initial random token key.
        /// </summary>
        /// <param name="senderPublicKey">
        /// The sender's public RSA key (PKCS#1 format). Required for recipients to verify the token signature.
        /// </param>
        /// <param name="senderPrivateKey">
        /// The sender's private RSA key (PKCS#8 format). Required for signing the generated token.
        /// </param>
        /// <param name="recipientPublicKey">
        /// The recipient's public RSA key (PKCS#1 format). Required for encrypting the token.
        /// </param>
        /// <param name="recipientPrivateKey">
        /// The recipient's private RSA key (PKCS#8 format). Required for decrypting the received token.
        /// </param>
        public RsaTokenGenerator(byte[]? senderPublicKey, byte[]? senderPrivateKey, byte[]? recipientPublicKey, byte[]? recipientPrivateKey)
        {
            _recipientPrivateKey = recipientPrivateKey;
            _recipientPublicKey = recipientPublicKey;
            _rsa = new RSACryptoServiceProvider(_RSAKEYSIZE);
            _senderPrivateKey = senderPrivateKey;
            _senderPublicKey = senderPublicKey;
            TokenKey = RandomNumberGenerator.GetBytes(((_RSAKEYSIZE - 384) / 8) + 6);
        }

        #endregion Public Constructors

        #region Properties

        /// <summary>
        /// Gets the symmetric token key generated by this instance. This key is intended to be
        /// exchanged securely.
        /// </summary>
        public byte[] TokenKey { get; private set; }

        #endregion Properties

        #region Fields

        /// <summary>
        /// The RSA key size used for the cryptographic operations within this class.
        /// Note: This is NOT the size used for generating external keys via GenerateKeys().
        /// </summary>
        private const int _RSAKEYSIZE = 720;

        /// <summary>
        /// Lock object for thread safety during RSA operations.
        /// </summary>
        private readonly object _lock = new object();

        /// <summary>
        /// The recipient's private RSA key (PKCS#8 format).
        /// </summary>
        private readonly byte[]? _recipientPrivateKey;

        /// <summary>
        /// The recipient's public RSA key (PKCS#1 format).
        /// </summary>
        private readonly byte[]? _recipientPublicKey;

        /// <summary>
        /// The RSA crypto service provider instance used for encryption/decryption and signing/verification.
        /// </summary>
        private readonly RSACryptoServiceProvider _rsa;

        /// <summary>
        /// The sender's private RSA key (PKCS#8 format).
        /// </summary>
        private readonly byte[]? _senderPrivateKey;

        /// <summary>
        /// The sender's public RSA key (PKCS#1 format).
        /// </summary>
        private readonly byte[]? _senderPublicKey;

        #endregion Fields

        #region Public Methods

        /// <summary>
        /// Generates a new pair of RSA keys (8192-bit) suitable for use with this class.
        /// </summary>
        /// <returns>
        /// A tuple containing the private key (PKCS#8 format) and the public key (PKCS#1 format).
        /// </returns>
        public static (byte[] PrivateKey, byte[] PublicKey) GenerateKeys()
        {
            using var rsa = new RSACryptoServiceProvider(8192);
            return (rsa.ExportPkcs8PrivateKey(), rsa.ExportRSAPublicKey());
        }

        /// <summary>
        /// Extracts the encrypted token key data segment from a combined token byte array. Assumes
        /// a specific token structure.
        /// </summary>
        /// <param name="token">
        /// The combined token byte array containing public key, signature, and encrypted data.
        /// </param>
        /// <returns>The byte array segment representing the encrypted token key.</returns>
        public static byte[] GetEncryptedData(byte[] token) => token.Take(new Range(2062, 3086)).ToArray();

        /// <summary>
        /// Extracts the sender's public key segment from a combined token byte array. Assumes a
        /// specific token structure.
        /// </summary>
        /// <param name="token">
        /// The combined token byte array containing public key, signature, and encrypted data.
        /// </param>
        /// <returns>The byte array segment representing the sender's public key.</returns>
        public static byte[] GetPublicKey(byte[] token) => token.Take(new Range(0, 1038)).ToArray();

        /// <summary>
        /// Extracts the signature segment from a combined token byte array. Assumes a specific
        /// token structure.
        /// </summary>
        /// <param name="token">
        /// The combined token byte array containing public key, signature, and encrypted data.
        /// </param>
        /// <returns>The byte array segment representing the signature.</returns>
        public static byte[] GetSignature(byte[] token) => token.Take(new Range(1038, 2062)).ToArray();

        /// <summary>
        /// Decrypts the encrypted data segment of a token using the recipient's private key and
        /// verifies the signature using the sender's public key provided during initialization.
        /// Updates the instance's <see cref="TokenKey"/> upon successful decryption and verification.
        /// </summary>
        /// <param name="token">The combined token byte array received from the sender.</param>
        /// <returns>The decrypted token key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the required sender public key or recipient private key was not provided
        /// during initialization.
        /// </exception>
        /// <exception cref="CryptographicException">
        /// Thrown if the public key embedded in the token does not match the expected sender public
        /// key, or if the signature verification fails.
        /// </exception>
        public byte[] DecryptToken(byte[] token)
        {
            if (_senderPublicKey == null)
            {
                throw new ArgumentNullException("senderPublicKey", "The public key of the sender is required for verification.");
            }
            if (_recipientPrivateKey == null)
            {
                throw new ArgumentNullException("recipientPrivateKey", "The private key of the recipient is required for decryption.");
            }
            if (!GetPublicKey(token).SequenceEqual(_senderPublicKey))
            {
                throw new CryptographicException("The public key of the sender does not match the public key of the token.");
            }
            lock (_lock)
            {
                _rsa.ImportPkcs8PrivateKey(_recipientPrivateKey, out int _);
                byte[] decryptedToken = _rsa.Decrypt(GetEncryptedData(token), true);
                _rsa.ImportRSAPublicKey(_senderPublicKey, out int _);
                if (!_rsa.VerifyData(decryptedToken, GetSignature(token), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1))
                {
                    throw new CryptographicException("The token data could not be verified using the token signature.");
                }
                return TokenKey = decryptedToken;
            }
        }

        /// <summary>
        /// Generates a combined token byte array containing the sender's public key, a signature of
        /// the <see cref="TokenKey"/> (signed with the sender's private key), and the <see
        /// cref="TokenKey"/> encrypted with the recipient's public key.
        /// </summary>
        /// <returns>The combined, encrypted, and signed token byte array ready for transmission.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the required recipient public key, sender private key, or sender public key
        /// was not provided during initialization.
        /// </exception>
        public byte[] GenerateEncryptedToken()
        {
            if (_recipientPublicKey == null)
            {
                throw new ArgumentNullException("recipientPublicKey", "The public key of the recipient is required for encrypting.");
            }
            if (_senderPrivateKey == null)
            {
                throw new ArgumentNullException("senderPrivateKey", "The private key of the sender is required for signing.");
            }
            if (_senderPublicKey == null)
            {
                throw new ArgumentNullException("senderPublicKey", "The public key of the sender is required for identification.");
            }

            lock (_lock)
            {
                _rsa.ImportRSAPublicKey(_recipientPublicKey, out int _);
                var encrypted = _rsa.Encrypt(TokenKey, true);
                _rsa.ImportPkcs8PrivateKey(_senderPrivateKey, out int _);
                return [.. _senderPublicKey, .. _rsa.SignData(TokenKey, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1), .. encrypted];
            }
        }

        #endregion Public Methods
    }
}